var documenterSearchIndex = {"docs":
[{"location":"api/#API","page":"API","title":"API","text":"","category":"section"},{"location":"api/#Modules","page":"API","title":"Modules","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"Order = [:module]","category":"page"},{"location":"api/#Types-and-constants","page":"API","title":"Types and constants","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"Order = [:type, :constant]","category":"page"},{"location":"api/#Functions-and-macros","page":"API","title":"Functions and macros","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"Order = [:macro, :function]","category":"page"},{"location":"api/#Documentation","page":"API","title":"Documentation","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"Modules = [MonotonicSplines]\nOrder = [:module, :type, :constant, :macro, :function]","category":"page"},{"location":"api/#MonotonicSplines.MonotonicSplines","page":"API","title":"MonotonicSplines.MonotonicSplines","text":"MonotonicSplines\n\nHigh-performance monotonic splines in Julia.\n\n\n\n\n\n","category":"module"},{"location":"api/#MonotonicSplines.InvRQSpline","page":"API","title":"MonotonicSplines.InvRQSpline","text":"struct InvRQSpline{T<:Real,N,...} <: Function\n\nRepresents the inverse of RQSpline.\n\nInvRQSpline holds the same spline knot parameters as the corresponding RQSpline.\n\nUsers should not instantiate InvRQSpline directly, use InverseFunctions.inverse(RQSpline(...)) instead.\n\n\n\n\n\n","category":"type"},{"location":"api/#MonotonicSplines.RQSpline","page":"API","title":"MonotonicSplines.RQSpline","text":"struct RQSpline{T<:Real,N,...} <: Function\n\nRepresents a rational quadratic spline function or a set of such functions for multiple dimensions and samples.\n\nImplements the splines originally proposed by Gregory and Delbourgo  (https://doi.org/10.1093/imanum/2.2.123)\n\nConstructors:\n\nRQSpline(pX::AbstractVector{<:Real}, pY::AbstractVector{<:Real}, dYdX::AbstractVector{<:Real})\nRQSpline(pX::AbstractArray{<:Real,3}, pY::AbstractArray{<:Real,3}, dYdX::AbstractArray{<:Real,3})\n\nFields:\n\npX: An array that holds the x-position of the spline knots.\npY: An array that holds the y-position of the spline knots.\ndYdX: An array that holds the derivative at the spline knots.\n\npX, pY and dYdX may be\n\nvectors of length K+1, representing a one-dimensional spline with K segments, or\nthree-dimensional arrays of the shape K+1 x n_dims x n_samples, representing a set of splines for different dimensions and input samples.\n\nRQSpline supports the InverseFunctions, ChangesOfVariables, and Functors APIs.\n\nExample:\n\n    using MonotonicSplines\n\n    f = RQSpline(posX, posX, dY_dX)\n    Y = f(X)\n\n    using InverseFunctions: inverse\n    X ≈ inverse(f)(Y)\n\n    using ChangesOfVariables: with_logabsdet_jacobian\n    Y, LADJ = with_logabsdet_jacobian(f, X)\n\nWhen instantiated as a set of multi-dimension/samples splines, RQSpline uses the package KernelAbstractions for parallel CPU or GPU processing. Custom ChainRulesCore rules are provided for effecient automatic differentation.\n\n\n\n\n\n","category":"type"},{"location":"api/#MonotonicSplines.estimate_dYdX-Tuple{AbstractVector{<:Real}, AbstractVector{<:Real}}","page":"API","title":"MonotonicSplines.estimate_dYdX","text":"MonotonicSplines.estimate_dYdX(pX::AbstractVector{<:Real}, pY::AbstractVector{<:Real})\n\nGet estimates for derivatives at the given knot points pX, pY.\n\nThe resulting derivatives can be used directly, but are also useful as initial values, when optimizing spline derivative parameters based on application-specific criteria.\n\nUses a linear estimate for the first and last knot and a 2nd order polynomial estimate over three knots for the other knots.\n\nExample:\n\ndYdX = MonotonicSplines.estimate_dYdX(pX, pY)\nf = RQSpline(pX, pY, dYdX)\n\n\n\n\n\n","category":"method"},{"location":"api/#MonotonicSplines.rqs_forward","page":"API","title":"MonotonicSplines.rqs_forward","text":"MonotonicSplines.rqs_forward(x::Real, pX::AbstractVector{<:Real}, pY::AbstractVector{<:Real}, dYdX::AbstractVector{<:Real})\nMonotonicSplines.rqs_forward(X::AbstractArray{<:Real,2}, pX::AbstractArray{<:Real,3}, pY::AbstractArray{<:Real,3}, dYdX::AbstractArray{<:Real,3})\n\nApply the rational quadratic spline function(s) defined by the parameters pX (pX), pY (pY), and dYdX (dYdX), to the input(s) X.\n\nSee RQSpline for more details.\n\n\n\n\n\n","category":"function"},{"location":"api/#MonotonicSplines.rqs_inverse","page":"API","title":"MonotonicSplines.rqs_inverse","text":"MonotonicSplines.rqs_inverse(x::Real, pX::AbstractVector{<:Real}, pY::AbstractVector{<:Real}, dYdX::AbstractVector{<:Real})\nMonotonicSplines.rqs_inverse(X::AbstractArray{<:Real,2}, pX::AbstractArray{<:Real,3}, pY::AbstractArray{<:Real,3}, dYdX::AbstractArray{<:Real,3})\n\nApply the inverse of the rational quadratic spline function(s) defined by the parameters pX (pX), pY (pY), and dYdX (dYdX), to the input(s) X.\n\nSee InvRQSpline for more details.\n\n\n\n\n\n","category":"function"},{"location":"api/#MonotonicSplines.rqs_params_from_nn","page":"API","title":"MonotonicSplines.rqs_params_from_nn","text":"MonotonicSplines.rqs_params_from_nn(θ_raw::AbstractArray, n_dims_trafo::Integer, B::Real = 5.)\n\nProcess the raw output parameters of a neural network to generate parameters for a set of rational quadratic spline functions.\n\nArguments\n\nθ_raw: A matrix where each column represents the raw parameters for a sample.\nn_dims_trafo: The number of spline functions for which parameters are to be produced.\nB: Sets the rage of the splines.\n\nReturns\n\nA tuple pX, pY, dYdX containing the positions of and derivatives at the spline knots. The parameters are stored in a K+1 x n_spline_functions_per_sample x n_samples array.\n\n\n\n\n\n","category":"function"},{"location":"introduction/#Introduction","page":"Introduction","title":"Introduction","text":"","category":"section"},{"location":"introduction/","page":"Introduction","title":"Introduction","text":"","category":"page"},{"location":"introduction/","page":"Introduction","title":"Introduction","text":"This page provides a summarized explanation of the implementation of the rational quadratic spline functions as defined in [1]. For a comprehensive derivation and explanation of the spline function's usage, see [1] and [2].","category":"page"},{"location":"introduction/","page":"Introduction","title":"Introduction","text":"Rational quadratic functions are defined as the quotient of two quadratic polynomials and offer superior flexibility to other function families [1]. They are easily differentiable, and since they are constructed to be monotonous, they also are analytically invertible. ","category":"page"},{"location":"introduction/","page":"Introduction","title":"Introduction","text":"Durkan et al. construct their rational quadratic splines f from K different rational quadratic functions. The parameterization of the splines follows the method of Gregory and Delbourgo [3]. They characterize a spline by the coordinates (x_ky_k)  k = 1  K+1, of the K+1 points called \\textit{knots} in which two adjacent spline segments are joined together. The parameterization also incorporates the K-1 derivatives of the spline at the interior knots. ","category":"page"},{"location":"introduction/","page":"Introduction","title":"Introduction","text":"limit the number of parameters needed to characterize a spline, they are defined on a finite interval","category":"page"},{"location":"introduction/","page":"Introduction","title":"Introduction","text":"\n    f  -B B rightarrow -B B   textwith B in mathbbR","category":"page"},{"location":"introduction/","page":"Introduction","title":"Introduction","text":"Here we chose B = 50 by default, but this can be changed arbitrarily. ","category":"page"},{"location":"introduction/","page":"Introduction","title":"Introduction","text":"Gregory and Delbourgo split this -B B input domain into K bins and define each spline segment on one bin. The knots lie on the bin edges on the x-axis and at the desired y value through which the spline is supposed to pass. ","category":"page"},{"location":"introduction/","page":"Introduction","title":"Introduction","text":"In the k-th bin (1leq k leq K), the respective spline segment f_k is defined as an expression of the coordinates (x_ky_k) and (x_k+1y_k+1) of the enclosing k -th and k+1 -st knots as well as the spline's derivatives delta_k and delta_k+1 at the knots:","category":"page"},{"location":"introduction/","page":"Introduction","title":"Introduction","text":"    f_k  x_k x_k+1) rightarrow -BB x mapsto y_k + frac(y_k+1-y_k)s_kxi^2+delta_kxi(1-xi)s_k+delta_k+1+delta_k-2s_kxi(1-xi)","category":"page"},{"location":"introduction/","page":"Introduction","title":"Introduction","text":"    textwhere quad s_k = s_k(x)= fracy_k+1 - y_kx_k+1-x quad textand quad xi = xi(x) = fracx - x_kx_k+1-x_k","category":"page"},{"location":"introduction/","page":"Introduction","title":"Introduction","text":"The spline function f is then defined piece-wise from the segment functions within each bin. The segments of the inverse spline function f^-1 are given by:","category":"page"},{"location":"introduction/","page":"Introduction","title":"Introduction","text":"    f_k^-1  y_k y_k+1) rightarrow -BB y mapsto x_k + frac(x_k+1-x_k)s_k(xi)^2+delta_kxi(1-xi)s_k+delta_k+1+delta_k-2s_kxi(1-xi)","category":"page"},{"location":"introduction/","page":"Introduction","title":"Introduction","text":"where","category":"page"},{"location":"introduction/","page":"Introduction","title":"Introduction","text":"    s_k = s_k(y)= fracx_k+1 - y_ky_k+1-y","category":"page"},{"location":"introduction/","page":"Introduction","title":"Introduction","text":"    xi = xi(y) = frac2c-b-sqrtb^2-4ac","category":"page"},{"location":"introduction/","page":"Introduction","title":"Introduction","text":"    a = a(y) = (y_k+1 - y_k)(s_k - delta_k) + (y-y_k)(delta_k+1+delta_k-2s_k)","category":"page"},{"location":"introduction/","page":"Introduction","title":"Introduction","text":"    b = b(y) = (y_k+1-y_k)delta_k-(y-y_k)(delta_k+1+delta_k-2s_k)7pt","category":"page"},{"location":"introduction/","page":"Introduction","title":"Introduction","text":"    c = c(y) = -s_k(y-y_k)","category":"page"},{"location":"introduction/","page":"Introduction","title":"Introduction","text":"The derivative for these functions can also be calculated analytically and are given by:","category":"page"},{"location":"introduction/","page":"Introduction","title":"Introduction","text":"    fractextdtextdx f_k(x) = fracs_k^2(delta_k+1xi^2+2s_kxi(1-xi)+delta_k(1-xi)^2)(s_k+(delta_k+1+delta_k-2s_k)xi(1-xi))^2 quad textand","category":"page"},{"location":"introduction/","page":"Introduction","title":"Introduction","text":"    fractextdtextdy f_k^-1(y) = frac1fractextdtextdxf_k(x) ","category":"page"},{"location":"introduction/","page":"Introduction","title":"Introduction","text":"Inside the -B B times -B B interval mask, the spline is characterized by the knots it passes through, as described above. Outside of this mask, f is set to be the identity function textid  mathbbR rightarrow mathbbR x mapsto x, to allow f to act on boundless input while retaining a finite number of parameters. ","category":"page"},{"location":"introduction/","page":"Introduction","title":"Introduction","text":"The outermost knots are set to be at the interval edges (x_1y_1)equiv(-B-B)  (x_Ky_K)equiv(BB) and the corresponding derivatives are set to be 1 to match the derivative of the identity function. Durkan et al. found this to improve the numerical stability of the Flow during training[1]. ","category":"page"},{"location":"introduction/","page":"Introduction","title":"Introduction","text":"With this construction, 3(K - 1) parameters are needed to fully characterize a spline function f : K + 1 sets of x_k and y_k coordinates for the knots, plus K + 1 derivatives delta_k minus the two fixed sets of coordinates and derivatives for the boundary knots.","category":"page"},{"location":"introduction/","page":"Introduction","title":"Introduction","text":"[1]: Conor Durkan, Artur Bekasov, Iain Murray, George Papamakarios Neural Spline Flows. arXiv:1906.04032","category":"page"},{"location":"introduction/","page":"Introduction","title":"Introduction","text":"[2]: Ivan Kobyzev, Simon J.D. Prince, Marcus A. Brubaker. *","category":"page"},{"location":"introduction/","page":"Introduction","title":"Introduction","text":"Normalizing Flows: An Introduction and Review of Current Methods*. arXiv:1908.09257","category":"page"},{"location":"introduction/","page":"Introduction","title":"Introduction","text":"[3]: J. A. GREGORY, R. DELBOURGO, Piecewise Rational Quadratic Interpolation to Monotonic Data. DOI:10.1093","category":"page"},{"location":"LICENSE/#LICENSE","page":"LICENSE","title":"LICENSE","text":"","category":"section"},{"location":"LICENSE/","page":"LICENSE","title":"LICENSE","text":"using Markdown\nMarkdown.parse_file(joinpath(@__DIR__, \"..\", \"..\", \"LICENSE.md\"))","category":"page"},{"location":"#MonotonicSplines.jl","page":"Home","title":"MonotonicSplines.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"This package provides a high-performance, GPU- and AD-friendly implementation of monotonic spline functions in Julia.","category":"page"},{"location":"","page":"Home","title":"Home","text":"The intended use cases is as a building block in Normalizing FLows, resp. parameter transformations in general.","category":"page"},{"location":"","page":"Home","title":"Home","text":"This package currently includes the monotonic rational quadratic splines as defined in \"Neural Spline Flows, Durkan et al. 2019\".","category":"page"},{"location":"","page":"Home","title":"Home","text":"MonotonicSplines currently implements rational quadratic splines as decribed in \"Neural Spline Flows, Durkan et al. 2019\".","category":"page"},{"location":"","page":"Home","title":"Home","text":"The splines defined here support the ChangesOfVariables, InverseFunctions and Functors APIs. The splines also come with some custom ChainRulesCore rrule methods to speed up automatic differentiation.","category":"page"},{"location":"","page":"Home","title":"Home","text":"The package uses KernelAbstractions to provide both GPU and multi-vendor GPU support.","category":"page"},{"location":"#Table-of-contents","page":"Home","title":"Table of contents","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"","category":"page"},{"location":"","page":"Home","title":"Home","text":"Pages = [\"introduction.md\", \"api.md\"]\nDepth = 3","category":"page"}]
}
